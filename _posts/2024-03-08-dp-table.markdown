---
title: "Dynamic Programming (DP Table)"
date: 2024-03-08
categories: [algorithms]
tags: [dynamic-programming, dp, python]
---

Dynamic Programming (DP) is a technique for solving problems by breaking them into subproblems and storing results to avoid redundant computation. This post introduces DP tables, their use cases, and provides practical Python examples and problems for mastering dynamic programming.

## Overview

**Dynamic Programming (DP)** is a technique used to solve problems by breaking them down into simpler subproblems and storing the results to avoid redundant computations.

A **DP table** is often used to store solutions to subproblems, typically in a 1D or 2D array.

- Top-down = recursion + memoization
- Bottom-up = iterative DP table filling

## üõ†Ô∏è How to Use (Python)

```python
# Example: Fibonacci with bottom-up DP
def fib(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)  # DP table to store results
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]  # Fill table iteratively
    return dp[n]
# Time complexity: O(n), Space complexity: O(n)
```

## üì¶ Use Cases

- Optimization problems
- Counting problems
- String matching (edit distance)
- Knapsack and variants
- Game theory (minimax + DP)

## üìò Sample Problem 1: Climbing Stairs

> You can take 1 or 2 steps. How many distinct ways to climb to the top?

```python
# This function counts the number of ways to climb n stairs (1 or 2 steps at a time).
def climb_stairs(n):
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]  # Ways to reach i = sum of previous two
    return dp[n]
# Time complexity: O(n), Space complexity: O(n)
```

## üìò Sample Problem 2: 0/1 Knapsack

> Given weights, values, and a capacity, find max value you can carry.

```python
# This function solves the 0/1 Knapsack problem using DP.
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]  # DP table
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i - 1] <= w:
                # Max of not taking or taking the item
                dp[i][w] = max(dp[i - 1][w], values[i - 1] + dp[i - 1][w - weights[i - 1]])
            else:
                dp[i][w] = dp[i - 1][w]
    return dp[n][capacity]
# Time complexity: O(n*capacity), Space complexity: O(n*capacity)
```

## üîÅ Variants

- Space optimized (e.g. 1D DP for Fibonacci)
- State compression (e.g. Bitmask DP)
- Tabulation vs memoization

---

