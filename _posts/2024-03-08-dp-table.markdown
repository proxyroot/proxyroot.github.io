---
title: "Dynamic Programming (DP Table)"
date: 2024-03-08
categories: [algorithms]
tags: [dynamic-programming, dp, python]
---

Dynamic Programming (DP) is a technique for solving problems by breaking them into subproblems and storing results to avoid redundant computation. This post introduces DP tables, their use cases, and provides practical Python examples and problems for mastering dynamic programming.

## Overview

**Dynamic Programming (DP)** is a technique used to solve problems by breaking them down into simpler subproblems and storing the results to avoid redundant computations.

A **DP table** is often used to store solutions to subproblems, typically in a 1D or 2D array.

- Top-down = recursion + memoization
- Bottom-up = iterative DP table filling

## üß© Visualizing Dynamic Programming

### Fibonacci DP Table

```
n = 5
DP Table: [0, 1, 1, 2, 3, 5]

Index:  0  1  2  3  4  5
Value:  0  1  1  2  3  5

Filling process:
dp[0] = 0 (base case)
dp[1] = 1 (base case)
dp[2] = dp[1] + dp[0] = 1 + 0 = 1
dp[3] = dp[2] + dp[1] = 1 + 1 = 2
dp[4] = dp[3] + dp[2] = 2 + 1 = 3
dp[5] = dp[4] + dp[3] = 3 + 2 = 5
```

### 2D DP Table (Knapsack)

```
weights = [1, 3, 4], values = [15, 20, 30], capacity = 5

DP Table (rows = items, cols = capacity):
     0  1  2  3  4  5
0    0  0  0  0  0  0
1    0 15 15 15 15 15
2    0 15 15 20 35 35
3    0 15 15 20 35 45
```

---

## üõ†Ô∏è How to Use (Python)

```python
# Example: Fibonacci with bottom-up DP
def fib(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)  # DP table to store results
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]  # Fill table iteratively
    return dp[n]
# Time complexity: O(n), Space complexity: O(n)

# Example:
print(fib(5))  # Output: 5
print(fib(10)) # Output: 55
```

---

## üß© Climbing Stairs Step-by-Step

Suppose n = 4

| i | dp[i-1] | dp[i-2] | dp[i] = dp[i-1] + dp[i-2] | Ways to reach i |
|---|---------|---------|---------------------------|-----------------|
| 1 | -       | -       | 1 (base case)             | [1]             |
| 2 | -       | -       | 2 (base case)             | [1,1], [2]      |
| 3 | 2       | 1       | 2 + 1 = 3                 | [1,1,1], [1,2], [2,1] |
| 4 | 3       | 2       | 3 + 2 = 5                 | [1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2] |

- Final result: 5 ways to climb 4 stairs.

---

## üìò Sample Problem 1: Climbing Stairs

> You can take 1 or 2 steps. How many distinct ways to climb to the top?

```python
# This function counts the number of ways to climb n stairs (1 or 2 steps at a time).
def climb_stairs(n):
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]  # Ways to reach i = sum of previous two
    return dp[n]
# Time complexity: O(n), Space complexity: O(n)

# Example:
n = 4
print(climb_stairs(n))  # Output: 5
```

---

## üß© 0/1 Knapsack Flow

Suppose weights = [1, 3, 4], values = [15, 20, 30], capacity = 5

| i | w | weights[i-1] | weights[i-1] <= w? | dp[i-1][w] | values[i-1] + dp[i-1][w-weights[i-1]] | dp[i][w] |
|---|----|--------------|-------------------|------------|----------------------------------------|----------|
| 1 | 1 | 1            | Yes               | 0          | 15 + 0 = 15                             | 15       |
| 1 | 2 | 1            | Yes               | 0          | 15 + 0 = 15                             | 15       |
| 1 | 3 | 1            | Yes               | 0          | 15 + 0 = 15                             | 15       |
| 1 | 4 | 1            | Yes               | 0          | 15 + 0 = 15                             | 15       |
| 1 | 5 | 1            | Yes               | 0          | 15 + 0 = 15                             | 15       |
| 2 | 1 | 3            | No                | 15         | -                                        | 15       |
| 2 | 2 | 3            | No                | 15         | -                                        | 15       |
| 2 | 3 | 3            | Yes               | 15         | 20 + 0 = 20                             | 20       |
| 2 | 4 | 3            | Yes               | 15         | 20 + 15 = 35                            | 35       |
| 2 | 5 | 3            | Yes               | 15         | 20 + 15 = 35                            | 35       |
| 3 | 1 | 4            | No                | 15         | -                                        | 15       |
| 3 | 2 | 4            | No                | 15         | -                                        | 15       |
| 3 | 3 | 4            | No                | 20         | -                                        | 20       |
| 3 | 4 | 4            | Yes               | 35         | 30 + 0 = 30                             | 35       |
| 3 | 5 | 4            | Yes               | 35         | 30 + 15 = 45                            | 45       |

- Final result: 45 (maximum value).

---

## üìò Sample Problem 2: 0/1 Knapsack

> Given weights, values, and a capacity, find max value you can carry.

```python
# This function solves the 0/1 Knapsack problem using DP.
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]  # DP table
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i - 1] <= w:
                # Max of not taking or taking the item
                dp[i][w] = max(dp[i - 1][w], values[i - 1] + dp[i - 1][w - weights[i - 1]])
            else:
                dp[i][w] = dp[i - 1][w]
    return dp[n][capacity]
# Time complexity: O(n*capacity), Space complexity: O(n*capacity)

# Example:
weights = [1, 3, 4]
values = [15, 20, 30]
capacity = 5
print(knapsack(weights, values, capacity))  # Output: 45
```

---

## üîÅ Variants

- Space optimized (e.g. 1D DP for Fibonacci)
- State compression (e.g. Bitmask DP)
- Tabulation vs memoization

---

